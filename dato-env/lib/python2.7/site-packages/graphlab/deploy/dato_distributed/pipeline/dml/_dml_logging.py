from graphlab_util import file_util
import logging
import urllib2
import threading
import time
import sys

__logger__ = logging.getLogger(__name__)


class LogPrinter(object):
    """
    The log printer streams log from the dml cluster, and
    print to the console.

    The log stream comes from two sources:
    1. the metric server while the job is running
    2. a final log file in hdfs when the job is done.

    While running, the log printer will first try print from metric
    server first. Content from the metric server will be
    accumulated into local variable: total_received_message.

    If no message from the metric server, we check the final log
    file. If final log file is avaiable, we print the remaining
    message from the log file and be done.
    """
    def __init__(self, log_server_address_file, final_log_file):
        self.final_log_file = final_log_file
        self.log_server_address_file = log_server_address_file
        self.log_server_address = ""
        self.total_received_message = ""
        self.finish = False

    def __del__(self):
        self.stop()

    def start(self):
        def thread_fun():
            while not self.finish:
                time.sleep(.5)
                if self._try_printing_from_streaming_server():
                    continue
                # If we print from the final log file, we are done
                if self._try_printing_from_final_log_file():
                    break

        self.thread = threading.Thread(target=thread_fun)
        self.thread.start()

    def stop(self):
        self.finish = True
        if (self.thread):
            self.thread.join()

    def _try_printing_from_streaming_server(self):
        if self.log_server_address == "":
            self.log_server_address = self._get_log_metric_server_address()
            if len(self.log_server_address) > 0:
                __logger__.debug('Connected to log server: %s' % self.log_server_address)
        if len(self.log_server_address) > 0:
            try:
                content = urllib2.urlopen(self.log_server_address).read()
                if len(content):
                    sys.stdout.write(content)
                    sys.stdout.flush()
                self.total_received_message += content
                return True
            except:
                pass
        return False

    def _get_log_metric_server_address(self):
        try:
            if file_util.exists(self.log_server_address_file):
                ret_str = file_util.read(self.log_server_address_file)
                if ret_str.endswith('$'):
                    return ret_str[:-1]
        except Exception as e:
            __logger__.warning(e)
        return ""

    def _try_printing_from_final_log_file(self):
        try:
            if file_util.exists(self.final_log_file):
                __logger__.debug("Read from %s" % self.final_log_file)
                content = file_util.read(self.final_log_file)
                leftover_progress_content = content[len(self.total_received_message):]
                # Final log file incomplete
                if not leftover_progress_content.endswith('$'):
                    return False

                if len(leftover_progress_content):
                    print leftover_progress_content[:-1]  # ignore $
                self.total_received_message += leftover_progress_content
                return True
        except Exception as e:
            __logger__.warning(e)
        return False
